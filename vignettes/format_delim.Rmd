---
title: "Format math delimiters"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Format math delimiters}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library("formatdown")
library("data.table")

# data.table printout
options(
  datatable.print.nrows = 15,
  datatable.print.topn = 3,
  datatable.print.class = TRUE
)
```


A branch to try replacing the `$...$` with `\(...\)`

```{r}
#| echo: false
# Remove trailing decimal point, if any, introduced by formatC()
omit_trailing_decimal <- function(DT, col_name) {

  # Logical. Identify rows with trailing decimal points
  rows_we_want <- DT[, get(col_name)] %like% "[:.:]$"

  # Delete trailing decimal points if any
  DT[rows_we_want, (col_name) := sub("[:.:]", "", get(col_name))]
}



format_power2 <- function(x,
                         digits = 3,
                         ...,
                         format = "engr",
                         omit_power = c(-1, 2), 
                         delim = "\\(") {

  # Arguments after dots must be named
  wrapr::stop_if_dot_args(
    substitute(list(...)),
    paste(
      "Arguments after ... must be named.\n",
      "* Did you forget to write `format = ` or `omit_power = `?\n *"
    )
  )

  # set omit_power to handle NULL or NA case
  if (sum(isTRUE(is.null(omit_power))) > 0 | sum(isTRUE(is.na(omit_power))) > 0 ) {
   # Assign equal fractional values and no integer exponents
   # can lie on this range
    omit_power <- c(0.1, 0.1)
    }

  # x: not "Date" class
  checkmate::assert_disjunct(class(x), c("Date", "POSIXct", "POSIXt"))

  # x: length at least one, numeric
  checkmate::qassert(x, "n+")

  # digits: numeric, not missing, length 1
  checkmate::qassert(digits, "N1")
  
  # give digits a max range

  # format: character, not missing, length 1
  checkmate::qassert(format, "S1")

  # format: element of a set
  checkmate::assert_choice(format, c("engr", "sci"))

  # omit_power: numeric, not missing, length 2
  checkmate::qassert(omit_power, "N2")

  # omit_power: range (p, q) requirement p <= q
  if (!isTRUE(all(omit_power == cummax(omit_power)))) {
    stop("In `omit_power = c(p, q)`, `p` must be less than or equal to `q`.")
  }

  # Indicate these are not unbound symbols (R CMD check Note)
  char_coeff <- NULL
  exponent <- NULL
  coeff <- NULL
  value <- NULL


  
  
  
  

  # ----- Initial processing

  # Convert vector to data.table for processing
  DT <- copy(data.frame(x))
  setDT(DT)

  # Indices to rows, separating decimal from exponential notation
  DT[, exponent := floor(log10(abs(x)))]
  decimal <- DT$exponent %between% omit_power
  pow_10  <- !decimal

  # Exponent multiple for scientific or engineering notation
  exp_multiple <- fcase(
    format == "engr", 3,
    format == "sci",  1
  )


  
  
  
  

  # ----- Rows with numbers in decimal notation

  # Create the character value to significant digits
  DT[decimal, value := formatC(signif(x, digits = digits), 
                               format = "fg", 
                               digits = digits, 
                               flag = "#")]

  # Remove trailing decimal point created by formatC() if any
  DT[decimal] <- omit_trailing_decimal(DT[decimal], "value")


  
  
  
  

  # ----- Rows with numbers in powers-of-ten notation

  # Determine numerical coefficient and exponent
  DT[pow_10, exponent := exp_multiple * floor(log10(abs(x)) / exp_multiple)]
  DT[pow_10, coeff := x / 10^exponent]

  # Create the character coefficient to significant digits
  DT[pow_10, char_coeff := formatC(coeff, format = "fg", digits = digits, flag = "#")]

  # Remove trailing decimal point created by formatC() if any
  DT[pow_10] <- omit_trailing_decimal(DT[pow_10], "char_coeff")

  # Construct powers-of-ten character string
  DT[pow_10, value := paste0(char_coeff, "\\times", "{10}^{", exponent, "}")]


  
  
  
  

  # ----- Complete the conversion for all value strings

  # Surround with math delimiters
  if (length(delim) == 1) {
    if (delim == "\\(" | delim == "\\)") {
      DT[, value := paste0("\\(", value, "\\)")]
    } else {
      DT[, value := paste0(delim, value, delim)] 
    }
  } else {
    DT[, value := paste0(delim[1], value, delim[2])]
  }

  # Convert to vector output
  DT <- DT[, (value)]

  # enable printing (see data.table FAQ 2.23)
  DT[]
}
```


```{r}
y <- format_power2(2.280E+4)
  
knitr::kable(y)

kableExtra::kbl(y)

y |> 
  kableExtra::kbl(align = "r") |>
  kableExtra::kable_paper(lightable_options = "basic", full_width = FALSE) |>
  kableExtra::row_spec(0, background = "#c7eae5") |>
  kableExtra::column_spec(1, color = "black", background = "white")
```

try inline: `r y`

## break

```{r}
temperature     <- seq(0, 45, 10) + 273.15
density         <- c(1000, 1000, 998, 996, 992)
specific_weight <- c(9809, 9807, 9793, 9768, 9734)
viscosity       <- c(173, 131, 102, 81.7, 67.0) * 1E-8
bulk_modulus    <- c(202, 210, 218, 225, 228) * 1E+7

water <- data.table(temperature, density, specific_weight, viscosity,  bulk_modulus)
```


```{r}
# Copy to avoid "by reference" changes to density
DT <- copy(water)

# Identify columns to format
cols_we_want <- c("viscosity", "bulk_modulus")

# Select and format.
DT <- DT[, (cols_we_want) := lapply(.SD, function(x) 
  format_power2(x, 4)), 
  .SDcols = cols_we_want]

DT$density <- format_power2(DT$density, 3, omit_power = c(0, 3))
DT$specific_weight <- format_power2(DT$specific_weight, 4, omit_power = c(0, 3))


```

```{r}
DT |> knitr::kable(align = "r")
```

```{r}
DT |> 
  kableExtra::kbl(align = "r") |>
  kableExtra::kable_paper(lightable_options = "basic", full_width = TRUE) |>
  kableExtra::row_spec(0, background = "#c7eae5") |>
  kableExtra::column_spec(1:5, color = "black", background = "white")
```

Inline math: water at temperature of \(0\)*C* has bulk modulus \(K =\) `r format_power2(bulk_modulus[1], 4)` *Pa* and viscosity \(\nu =\) `r format_power2(viscosity[1], 4)` *Pa-s*. 

Inline math: water at temperature of $0$*C* has bulk modulus $K =$ `r format_power(bulk_modulus[1], 4)` *Pa* and viscosity $\nu =$ `r format_power(viscosity[1], 4)` *Pa-s*. 


Display equations, 

\[
N_A = 6.0221\times{10}^{23}
\]

and using dollars 

$$
N_A = 6.0221\times{10}^{23}
$$


```{r}
format_power(bulk_modulus[1], 4)


format_power2(bulk_modulus[1], 4)
```

