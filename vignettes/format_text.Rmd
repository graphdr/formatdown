---
title: "Format text"
vignette: >
  %\VignetteIndexEntry{Format text}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: ../inst/information-science-and-technology.csl
link-citations: yes
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  tidy = TRUE
)

# to knit "child" Rmd files
knitr::opts_knit$set(root.dir = "../")

library(formatdown)
library(data.table)
library(knitr)

options(
  datatable.print.nrows = 15,
  datatable.print.topn = 3,
  datatable.print.class = TRUE
)
```

```{r}
#| echo: false

# make header table, but scan it and save as png

# Markup <- c("$\\small\\mathtt{\\verb+\\mathrm{...}+}$", "$\\small\\mathtt{\\verb+\\mathit{...}+}$", "$\\small\\mathtt{\\verb+\\mathbf{...}+}$", "$\\small\\mathtt{\\verb+\\mathsf{...}+}$", "$\\small\\mathtt{\\verb+\\mathtt{...}+}$")
# 
# Style <- c("$\\small\\mathrm{plain}$", "$\\small\\mathit{italic}$", "$\\small\\mathbf{bold}$", "$\\small\\mathsf{sans\\ serif}$", "$\\small\\mathtt{typewriter}$")
# 
# DT <- data.table(Markup, Style)
# knitr::kable(DT, align = "l") |>
#   kableExtra::kable_styling(font_size = 16, position = "left") |>
#   kableExtra::column_spec(1:2, width = "2in")
```

![](../man/figures/latex_math_formatting_text_table_2.png){width=70%}    

<br>

Columns of text in a data table will generally not be rendered in the same typeface as produced by `format_numbers()`. The `format_text()` function provides an approach to assigning a matching typeface to such columns.  


<br>

```{r child = "man/rmd/note-packages.Rmd"}
``` 


## Markup

We format values as inline math expressions delimited by `$ ... $` or the optional `\( ... \)`. Inside the math delimiters, the text is formatted using math-text macros such as `\mathrm`, `\mathit`, etc. 

For example, the text "Hello world!" is marked up as follows, where the space between words is preserved by a horizontal space macro (`\>`), 

        $\mathrm{Hello\>world!}$

and is rendered in an R markdown document as 

$\qquad\small\mathrm{Hello\>world!}$

<br>

To *program* the markup, however, we enclose the markup in quote marks as a character string, that is, 

        "$\\mathrm{Hello\\>world!}$"

where extra backslashes are necessary to "escape" the backslashes in `\mathrm` and `\>`. 










## `format_text()`

Converts a character vector (or a vector coercible to character class) to math-text of the form, 

        "$\\math**{some_text}$" 
 
where `some_text` is the text to be formatted and  `\\math**` is a font face macro such as `\\mathrm`, `\\mathit`, etc. 

<br>

*Arguments.*

x

: Text to be formatted. Can be a scalar, a vector, or a column from a data frame. Non-characters are coerced to character class if possible. 

face

: Font face. Possible values are "plain" (default), "italic", "bold", "sans", or "mono". Adds a prefix to the markup to invoke the macros `\mathrm`, `\mathit`, `\mathbf`, `\mathsf`, or `\mathtt`. 

size, delim, word_space

: Global options used for setting font size, math-delimiters, and interword spacing. For details, see the help page for `formatdown_options()`. Any  globally-set argument is overridden locally if the argument is declared in the function.  

<br>

*Equivalent usage.*  &nbsp;  The first two arguments do not have to be named if the argument order is maintained. 

```{r}
# Character string
hello_text <- "Hello world!"

# Arguments named
(p <- format_text(x = hello_text, face = "plain"))

# Arguments unnamed
q <- format_text(hello_text, "plain")

# Implicit use of default argument
r <- format_text(hello_text)

# Demonstrate equivalence
all.equal(p, q)
all.equal(p, r)
```




## Input coercible to character

Illustrating that variables of different classes are coerced to character if possible. Starting with character class, 

```{r}
# class
x <- c("abc", "def", NA_character_)
class(x)

# markup result
format_text(x)
```

renders as: `r format_text(x, size = "small")`.  Next, numeric class, 

```{r}
# class
x <- c(10, 3E-5, 4.56E+10)
class(x)

# markup result
format_text(x)
```

renders as: `r format_text(x, size = "small")`. Next, logical class, 

```{r}
# class
x <- TRUE
class(x)

# markup result
format_text(x)
```

renders as: `r format_text(x, size = "small")`. Next complex number class, 

```{r}
# class
x <- 2 + 3i
class(x)

# markup result
format_text(x)
```

renders as: `r format_text(x, size = "small")`. Next, Date class, 

```{r}
# class
x <- Sys.Date()
class(x)

# markup result
format_text(x)
```

renders as: `r format_text(x, size = "small")`. Next, factor class, 

```{r}
# class
x <- as.factor(c("low", "med", "high"))
class(x)

# markup result
format_text(x)
```

renders as: `r format_text(x, size = "small")`. And finally, NULL class, 

```{r}
# class
x <- NULL
class(x)

# markup result
format_text(x)
```

which is a length-zero character.  


## Font size

Format the same column of text using each of the five possible `size` arguments for comparison. 

```{r}
x <- c("low", "med", "high")

script <- format_text(x, size = "scriptsize")
small  <- format_text(x, size = "small")
normal <- format_text(x, size = "normalsize")
large  <- format_text(x, size = "large")
huge   <- format_text(x, size = "huge")

# Compare formats
DT <- data.table(script, small, normal, large, huge)
knitr::kable(DT, align = "r")
```




## Typeface

Format the same column of text using each of the five possible `face` arguments for comparison. 

```{r}
# Compare formats
DT <- data.table(
  plain  = format_text(x, face = "plain"),
  italic = format_text(x, face = "italic"),
  bold   = format_text(x, face = "bold"),
  sans   = format_text(x, face = "sans"),
  mono   = format_text(x, face = "mono")
)
knitr::kable(DT, align = "r")
```




## Special characters in math mode

The argument of `format_text()` is evaluated within a math-markup. Thus math syntax such as an underscore "_" or caret "^" in your text are rendered in math mode, not verbatim. For example, the underscore creates a subscript and the caret creates a superscript, 

```{r}
format_text("R_e")
format_text("m^3")
```

rendered as

- `r format_text("R_e")` 
- `r format_text("m^3")`

To retain the underscore or caret as characters, we can try to escape the special character or use the LaTeX verbatim function,  

```{r}
format_text("R\\_e")
format_text("m\\verb|^|3")
```

rendered as

- `r format_text("R\\_e")`
- `r format_text("m\\verb|^|3")`







## Tables of data

`format_text()` permits us to format text columns in the same font face and size as the numeric columns formatted with  `format_numbers()` and its derivatives. The example uses the `metals` data included with formatdown. 

```{r}
#| echo: false
formatdown_options(size = "small")
```

First, we'll format the numerical columns, 

```{r}
# Copy to avoid "by reference" changes to air_meas
DT <- copy(metals)

# Integer and decimal columns
cols_we_want <- c("dens", "thrm_cond")
DT[, (cols_we_want) := lapply(.SD, function(x) format_dcml(x, 3)), .SDcols = cols_we_want]

# Power-of-ten columns
cols_we_want <- c("thrm_exp", "elast_mod")
DT[, (cols_we_want) := lapply(.SD, function(x) format_engr(x, 3)), .SDcols = cols_we_want]

# Render in document
knitr::kable(DT,
  align = "lrrrr",
  caption = "Unformatted text; formatted numbers.")
```

<br>

Next we'll format the text column for a consistent visual aesthetic. 
 
```{r}
# Text column
DT$metal <- format_text(DT$metal)

# Render in document
knitr::kable(DT,
  align = "lrrrr",
  caption = "Text column formatted to match.")
```


```{r}
#| echo: false
reset_formatdown_options()
```





## References

