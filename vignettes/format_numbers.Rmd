---
title: "Format numbers"
vignette: >
  %\VignetteIndexEntry{Format numbers}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: ../inst/information-science-and-technology.csl
link-citations: yes
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  tidy = TRUE
)

# to knit "child" Rmd files
knitr::opts_knit$set(root.dir = "../")

library(formatdown)
library(data.table)
library(knitr)

options(
  datatable.print.nrows = 15,
  datatable.print.topn = 3,
  datatable.print.class = TRUE
)
```


<!-- # TO-DO -->
<!-- # revise format_numbers to handle units class     -->
<!-- # # Start with a numeric value      -->
<!-- # G <- 6.67384e-11      -->
<!-- #  -->
<!-- # # Do some units things      -->
<!-- # display_units <- "m3 kg-1 s-2"      -->
<!-- # units(G) <- display_units      -->
<!-- #  -->
<!-- # # Convert back to numeric to power formatting      -->
<!-- # G <- format_power(as.numeric(G))      -->
<!-- #  -->
<!-- # # Paste the display units to the result      -->
<!-- # G <- paste0(G, " [", display_units, "]")      -->
<!-- # G -->




```{r}
#| echo: false

formatdown_options(size = "small")

prefix_1 <- c("peta", "tera", "giga", "mega", "kilo")

symbol_1 <- c("P", "T", "G", "M", "k")
symbol_1 <- format_text(symbol_1, face = "italic")

x <- 10^seq(from = 15, to = 3, by = -3)
value_1 <- format_numbers(x, digits = 1, format = "engr", omit_power = NULL)
value_1 <- sub("1 \\\\times ", "", value_1)

prefix_2 <- c("milli", "micro", "nano", "pico", "femto")

symbol_2 <- c("m", "\\mu", "n", "p", "f")
symbol_2 <- format_text(symbol_2, face = "italic")

x <- 10^seq(from = -3, to = -15, by = -3)
value_2 <- format_numbers(x, 1, omit_power = NULL)
value_2 <- sub("1 \\\\times ", "", value_2)

DT <- data.table(prefix_1, symbol_1, value_1, prefix_2, symbol_2, value_2)
knitr::kable(DT,
             align = "lcllcl",
             col.names = rep(c("Prefix", "Symbol", "Value"), 2))
```

```{r child = "man/rmd/note-formatdown-rationale.Rmd"}
``` 
In this vignette, we discuss the primary formatting function `format_numbers()` and its convenience wrappers for scientific, engineering, and decimal notation.

## Types of notation

Notation to represent large and small numbers depends on the mode of communication. In a computer script, for example, we might encode the Avogadro constant as `N_A = 6.0221*10^23`. The asterisk (\*) and caret (\^) in this expression, however, communicate *instructions to a computer*, not *syntactical mathematics*. And while scientific E-notation (`6.0221E+23`) has currency in some discourse communities, power-of-ten notation, e.g., $\small N_A = 6.0221 \times 10^{23}$, is the conventional format for professional technical communication. 

Power-of-ten notation is expressed,   

$$
\small a \times 10^n, 
$$

where $\small a$ is the coefficient in decimal form and the exponent $\small n$ is an integer. Two formats are in common use [@Chase:2021, 63--67]: 

- *scientific:* &nbsp; $\small 1\leq{|a|} < 10$, e.g., $\small N_A =$ `r format_sci(6.0221E+23, 5)`. 

- *engineering:* &nbsp; $\small  1\leq{|a|} < 1000$ and $\small n$ is a multiple of 3, e.g., $\small N_A =$ `r format_engr(6.0221E+23, 5)`. 

The utility of the engineering form follows from the SI prefixes for physical units such as "mega-", "kilo-", "milli-", etc., corresponding to powers of 10 that are integer multiples of three. 

<br>

*Notes on syntax.* &nbsp; Programming symbols are not necessarily mathematical symbols:

- asterisk (\*). Programming symbol for multiplication, e.g., `x = a * b` or `y = a * (b + c)`. In the grammar of mathematics, multiplication is indicated by the symbol ($\times$) when needed.   

- caret (\^). Programming symbol for exponentiation, e.g., `x = y^2` or `z = 10^-3`. In the grammar of mathematics, exponents are typeset as superscripts, e.g., $\small x = y^2$ or $\small z = 10^{-3}$.

- multiplication ($\small\times$). Mathematical symbol for multiplication, not to be confused with the letter "x". Generally omitted when the meaning is clear, e.g., $\small x=ab$ or $\small y=a(b+c)$, but conventionally included in power-of-ten notation, e.g., $\small 6.0221 \times 10^{23}$. When a comma is used as the decimal marker, multiplication may be indicated by the half-high dot, e.g., $\small 6,0221 \cdot 10^{23}$.

<br>

*Decimal subsets.* &nbsp; In a vector of numbers formatted in power-of-ten form, the decimal form may be preferred for any subset of values with exponents near zero, e.g., $\small n \in \{-1, 0, 1, 2\}$. 


```{r}
#| echo: false

x <- 3.12 * 10^seq(-3, 4)

sci  <- format_sci(x, 3, omit_power = NA)
sci_omit <- format_sci(x, 3)
DT <- data.table(sci, sci_omit)

knitr::kable(DT,
  align = "r",
  caption = "Decimal form may be preferred for a subset", 
  col.names = c( 
    "scientific notation", 
    "subset in decimal form"
  )
)
```

<br>

*Decimal columns.* &nbsp; A table of numeric information can include columns formatted in both power-of-ten notation and decimal notation. For example, a  table of atmospheric properties shown below has altitude in integer form, temperature in decimal form,  and density in power-of-ten engineering notation (except for those values with exponents near zero). 

```{r}
#| echo: false

DT <- atmos[alt < 150, .(alt, temp, dens)]

DT$alt <- format_dcml(DT$alt, 2)
DT$temp <- format_dcml(DT$temp, 5)
DT$dens <- format_engr(DT$dens, 3)
knitr::kable(DT,
  align = "r",
  caption = "Properties of the atmosphere", 
  col.names = c( 
    "Altitude (km)", 
    "Temperature (K)", 
    "Density (kg/m$^3$)"
  )
)

reset_formatdown_options()
```

The purpose of the decimal format in formatdown is to match the font face and size of decimal columns to those of the power-of-ten columns. If no power-of-ten columns are used, of course, decimal columns can be displayed as-is or formatted using other R tools. 

<br>

```{r child = "man/rmd/note-packages.Rmd"}
``` 

## Markup {#markup}

We format values as inline math expressions  delimited by `$ ... $` or the optional `\( ... \)`. For example, the Avogadro constant is marked up as

        $6.0221 \times 10^{23}$, 

and rendered in an R markdown document as $\small 6.0221 \times 10^{23}$. To *program* the markup, however, we enclose the markup in quote marks as a character string, that is, 

        "$6.0221 \\times 10^{23}$".

An extra backslash is necessary to "escape" the backslash in `\times`.

## `format_numbers()` {#format_num}

Given a number, a numerical vector, or a numerical column from a data frame, `format_numbers()` converts the numbers to character strings in a power-of-ten form, 

        "$a \\times 10^{n}$" 

or in decimal form, 

        "$a$" 

where $\small a$ is coefficient (or decimal number), `\\times` is the macro for the multiplication symbol ($\small \times$), and $\small n$ is the exponent. 

<br>

*Arguments.* 

x

: Numerical vector to be formatted. Can be a scalar, a vector, or a column from a data frame. Can include NA elements. 

```{r child = "man/rmd/define-digits.Rmd"}
``` 

format

: Possible values are `"engr"` (default) for engineering notation, `"sci"` for scientific notation, and `"dcml"` for decimal notation. 

omit_power

: Numeric vector `c(p, q)` with `p <= q`, specifying the range of exponents over which power-of-ten notation is omitted in either scientific or engineering power-of-ten format. Default is `c(-1, 2)`. If a single value is assigned, i.e., `omit_power = p`, the argument is interpreted as `c(p, p)`. If `NULL` or `NA`, all elements are formatted in power-of-ten notation. Argument is overridden by a non-empty `set_power` or if decimal notation is specified (`format = "dcml"`). 

set_power

: Integer scalar. In scientific or engineering notation, formats all values in `x` with the same power-of-ten exponent. Default NULL. Argument overrides `omit_power`. Argument is overridden if decimal notation is specified.

```{r child = "man/rmd/define-options.Rmd"}
``` 
 
<br>

*Equivalent usage.*  &nbsp;  The first three arguments do not have to be named if the argument order is maintained. 

```{r}
# Numerical value
avogadro <- 6.0221E+23

# Arguments named
(x <- format_numbers(x = avogadro, digits = 4, format = "engr"))

# Arguments unnamed
y <- format_numbers(avogadro, 4, "engr")

# Implicit use of default argument
z <- format_numbers(avogadro)

# Demonstrate equivalence
all.equal(x, y)
all.equal(x, z)
```

## Convenience functions

Each of the primary formats (`"sci"`, `"engr"`, and `"dcml"`) can be accessed with its own convenience function that wraps `format_numbers()`. 

*Usage.*

- `format_dcml(x, digits, <options>)`
- `format_engr(x, digits, omit_power, set_power, <options>)`
- `format_sci (x, digits, omit_power, set_power, <options>)`

Examples of equivalence between the wrappers and `format_numbers()`. First, in decimal notation, 

```{r}
(x <- 101300)
(p <- format_dcml(x, 3))
(q <- format_numbers(x, 3, "dcml"))
all.equal(p, q)
```

In engineering notation, 

```{r}
(x <- avogadro)
(p <- format_engr(x, 3))
(q <- format_numbers(x, 3, "engr"))
all.equal(p, q)
```

And in scientific notation, 

```{r}
(x <- avogadro)
(p <- format_sci(x, 3))
(q <- format_numbers(x, 3, "sci"))
all.equal(p, q)
```

Optional arguments can be set in individual function calls or set globally; see [Global settings](#global-settings). For example, the following produce identical results, 

```{r}
(x <- avogadro)
(p <- format_sci(x, 3, size = "small"))
(q <- format_numbers(x, 3, "sci", size = "small"))
all.equal(p, q)
```






## Numeric input {#input}

*Scalar.* &nbsp; Use with inline R code. For example, the following Quarto or RMarkdown sentence fragment that includes some math markup and some inline R code,  

````{verbatim}
    $N_A = $ `r format_sci(6.022E+23, 4)`
````

is rendered as 

$\qquad\small N_A =$ `r format_numbers(6.022E+23, 4, "sci", size = "small")`.

<br>

*Vector.* &nbsp; Given a vector of numbers (or a data frame column), 

```{r}
x <- c(2.3333e-5, 3.4444e-4, 5.2222e-2, 6.3333e-1, 8.1111e+1, 9.2222e+2, 2.4444e+4, 3.1111e+5, 4.2222e+6)
format_engr(x)
```

the formatted values are rendered as, 

```{r}
#| echo: false
formatdown_options(size = "small")
```

```{r}
DT <- data.table(x, format_engr(x))
knitr::kable(DT, align = "r", col.names = c("x", "Default formatting"))
```

```{r}
#| echo: false
reset_formatdown_options()
```

Comments:

- Default significant digits is 4. 
- For values with exponents $\small n\in\{-1, 0, 1, 2\}$, the default format is decimal. 

## Significant digits {#significant-digits}

Argument does not have to be named. Default is 4. 

Significant digits are applied to the input argument using the base R function `signif()` before additional formatting is applied.  For example, 

```{r}
# Value
(y <- 2.3333e-5)
```

when formatted with different numbers of significant digits, 

```{r}
#| echo: false

formatdown_options(size = "small")

y <- 2.3333e-5

r <- c(format_sci(y, 3), format_sci(y, 4), format_sci(y, 5))

s <- c("format\\_sci(y, 3)", "format\\_sci(y, 4)", "format\\_sci(y, 5)")

s <- format_text(s, face = "mono")

DT <- data.table(s, r)

knitr::kable(DT, 
             align = "lr", 
             col.names = c("function call", "renders as"))

reset_formatdown_options()
```

## Formats {#formats}

The `format` argument appears in `format_numbers()` only. The default is "engr". In the convenience functions `format_dcml()`, `format_engr()`, and `format_sci()`, the format is preset. 

To compare the effects across many orders of magnitude, we display the same vector in different formats.

```{r}
#| echo: false
formatdown_options(size = "small")
```

```{r}
x <- c(2.3333e-5, 3.4444e-4, 5.2222e-2, 6.3333e-1, 8.1111e+1, 9.2222e+2, 2.4444e+4, 3.1111e+5, 4.2222e+6)

# Compare three formats
dcml <- format_numbers(x, 3, "dcml")
sci  <- format_numbers(x, 3, "sci")
engr <- format_numbers(x, 3, "engr")
DT   <- data.table(dcml, sci, engr)
knitr::kable(DT, 
             align = "r", 
             col.names = c("decimal", "scientific", "engineering"))
```

```{r}
#| echo: false
reset_formatdown_options()
```

The values displayed without powers-of-ten notation in the scientific and engineering columns are determined by the `omit_power` argument discussed next.  

## Excluding a range of exponents {#excluding-exponents}

Argument `omit_power`, if included, must be named. Default is `c(-1, 2)`.

Numbers with exponents within the range of `omit_power` are typeset in decimal form; all other numbers are typeset in power-of-ten form. In engineering format, being "within the range" applies to exponents both before and after the conversion to engineering form. 

To illustrate, we compare two `omit_power` settings in both scientific and engineering formats. 

```{r}
#| echo: false
formatdown_options(size = "small")
```

```{r}
DT <- atmos[3:12, .(pres)]
DT[, sci1  := format_sci (pres , 3, omit_power = NULL)]
DT[, sci2  := format_sci (pres , 3, omit_power = c(-1, 0))]
DT[, engr1 := format_engr(pres , 3, omit_power = NULL)]
DT[, engr2 := format_engr(pres , 3, omit_power = c(-1, 0))]
knitr::kable(DT, 
             align = "r", 
             col.names = c("pressure", 
                         "all scientific", 
                         "scientific w/ omit", 
                         "all engineering", 
                         "engineering w/ omit"))
```

Comments: 

- Setting `omit_ower = NULL` imposes power-of-ten-notation for an entire column. 
- In the "scientific with omit" column, the three values $\small (0.184, 1.05, 5.22)$ are in decimal form because their exponents lie within the `omit_power` range $\small \{-1, 0\}$. 
- In the "engineering with omit" column, these values are again in decimal form because *before* converting to engineering form their exponents lie within the `omit_power` range. 
- Additionally in the "engineering with omit" column, the values $(\small 22, 80, 287)$ are in decimal form because *after* converting to engineering notation their exponents lie within the `omit_power` range. 

<br>

If a single value is assigned, e.g., `omit_power = 0`, the argument is interpreted as `c(0, 0)`.

```{r}
DT <- atmos[3:12, .(pres)]
DT[, sci1  := format_sci(pres, 3, omit_power = NULL)]
DT[, sci2  := format_sci(pres, 3, omit_power = 0)]
DT[, engr1 := format_engr(pres, 3, omit_power = NULL)]
DT[, engr2 := format_engr(pres, 3, omit_power = 0)]
knitr::kable(DT, 
             align = "r", 
             col.names = c("pressure", 
                         "all scientific", 
                         "scientific w/ omit", 
                         "all engineering", 
                         "engineering w/ omit"))
```

```{r}
#| echo: false
reset_formatdown_options()
```

<br>

Setting `omit_power = c(-Inf, Inf)` yields the same decimal result as `format = "dcml"` and overrides any other `format` setting. For example, 

```{r}
(y <- 6.78e-3)

(p <- format_numbers(y, 3, "sci", omit_power = c(-Inf, Inf)))

(q <- format_numbers(y, 3, "dcml"))

(r <- format_dcml(y, 3))

all.equal(p, q)
all.equal(p, r)
```

and all render as `r format_numbers(y, 3, "dcml", size = "small")`

## Enforcing a specific exponent {#enforcing-exponent}

Argument `set_power`, if included, must be named. Default is NULL. 

When values in a table column span only a few orders of magnitude, an audience is sometimes better served by setting the notation to a constant power of ten. For example, here we show numbers in scientific format and compare to columns in which the exponents are set to fixed values. 

```{r}
#| echo: false
formatdown_options(size = "small")
```

```{r}
DT <- atmos[alt <= 40, .(alt, pres, dens)]

DT[, pres_sci := format_numbers(pres, 3, format = "sci", omit_power = c(-1, 2))]
DT[, pres_set := format_numbers(pres, 3, format = "sci", omit_power = c(-1, 2), set_power = 3)]
DT[, dens_sci := format_numbers(dens, 3, format = "engr", omit_power = c(-1, 2))]
DT[, dens_set := format_numbers(dens, 3, format = "engr", omit_power = c(-1, 2), set_power = -2)]
DT[, pres := NULL]
DT[, dens := NULL]
knitr::kable(DT, 
             align = "r", 
             col.names = c('Altitude (km)', 'Pressure (Pa)', 'with set_power', 'Density (kg/m$^{3}$)', 'with set_power'))
```

```{r}
#| echo: false
reset_formatdown_options()
```

Assigning a value to `set_power` overrides `omit_power` and (if present)  `format`. 

## Optional arguments

Optional arguments `size`, `delim`, `decimal_mark`, `big_mark`, and `small_mark` can be set one of two ways: locally (by name) in the function call or globally (see [Global settings](#global-settings)). 

### Font size {#font-size}

Adds a LaTeX-style font size command inside the math delimiters. For example, with `size = "small"`, the math markup of the Avogadro constant would be  

        $\\small 6.0221 \times 10^{23}$, 

where again, an extra backslash is necessary.  If `size = NA` (default), no size command is added. 

In the example below, we format the same column of text using each of the five possible `size` arguments for comparison. 

```{r}
y <- c(1E-3, 3E+0, 5E+3)
script <- format_sci(y, 1, size = "scriptsize")
small  <- format_sci(y, 1, size = "small")
normal <- format_sci(y, 1, size = "normalsize")
large  <- format_sci(y, 1, size = "large")
huge   <- format_sci(y, 1, size = "huge")
  
# View a sample markup
small
  
# Compare formats
DT <- data.table(script, small, normal, large, huge)
knitr::kable(DT, align = "r")
```

Comparing the output of `size = NA` and `size = "normalsize"`, the math markup is different but the rendered output is identical. 

```{r}
# A value
(y <- 2.3333e-5)

# Markup with size = NA
(p <- format_engr(y, 3, size = NA))

# Markup with size = "normalsize"
(q <- format_engr(y, 4, size = "normalsize"))
```

```{r}
#| echo: false
func_call <- c('format\\_engr(y, 3, size = NA)', 'format\\_engr(y, 4, size = "normalsize")')

func_call <- format_text(func_call, face = "mono")

func_eval <- c(p, q)


DT <- data.table(func_call, func_eval)

knitr::kable(DT, 
             align = "lr", 
             col.names = c("function call", "renders as"), 
             caption = 'Font size "NA" and "normalsize" are identically rendered')
```

### Delimiters {#delimiters}

Characters that surround a formatted number such that it can be rendered in an R Markdown document as an inline math expression. Default is `"$"`. 
 
```{r}
x <- 2.1e-4

# View markup
format_numbers(x)

# Equivalent usage
p <- format_numbers(x)
q <- format_numbers(x, delim = "$")
r <- format_numbers(x, delim = c("$", "$"))

# Verify equivalence
all.equal(p, q)
all.equal(p, r)
```

all of which render as 

- `r format_numbers(x, size = "small")`

I encountered one instance --- when using `kableExtra::kbl()` to create a table in a `.qmd` output document --- in which the `$ ... $` delimiters did not produce the desired output. Switching the delimiters to `\( ... \)` fixed the problem, per the recommendation of the MathJax consortium [@Cervone:2018]. 

In this specific instance, you can assign either left or right delimiters, or both. Again we encounter a case where the backslash must be escaped. 

```{r}
# View markup
format_numbers(x, delim = "\\(")

# Equivalent usage
p <- format_numbers(x, delim = "\\(")
q <- format_numbers(x, delim = "\\)")
r <- format_numbers(x, delim = c("\\(", "\\)"))

# Verify equivalence
all.equal(p, q)
all.equal(p, r)
```

are all rendered as 

- `r format_numbers(x, delim = "\\(", size = "small")`

If your markup environment requires delimiters other than `$...$` or `\(...\)`, you must specify both left and right delimiters, similar to the following. You may have to escape any special characters.  

        # Specifying left and right delimiters
        format_numbers(x, delim = c("$", "$"))
        format_numbers(x, delim = c("\\(", "\\)"))

### Digit grouping {#digit-grouping}

Three separators for grouping digits are available.  

- `decimal_mark`, passed to the `decimal.mark` argument of `formatC()`. Default is (`"."`).
- `big_mark`, passed to the `big.mark` argument of `formatC()`. Default is empty (`""`). 
- `small_mark`, passed to the `small.mark` argument of `formatC()`. Default is empty (`""`). 

<br>

*Decimal mark.* &nbsp; The decimal mark separates the integer part from the fractional part of a number written in decimal form. The argument may not be assigned the same symbol as `big_mark`. 

The convention in Australia, English-speaking Canada, China, Ireland, Japan, Korea, Mexico, the United Kingdom, the United States, and other regions is the period ("."). The convention in Brazil, French-speaking Canada, France, much of Latin America, Poland, Portugal, Russia, Scandinavia, Ukraine, and other regions is the comma (","). 

The decimal mark in R can be reset with `options(OutDec = ",")`. The decimal mark in formatdown must be reset either locally in a function call or globally using `formatdown_options()`. 

```{r}
#| echo: false
formatdown_options(size = "small")
```

```{r}
# Preserve user's current options settings
backup_options <- options()

# Set R decimal mark to a comma
options(OutDec = ",")

# Format two columns using format_numbers() with decimal_mark argument
DT <- atmos[1:12, .(pres)]
DT[, sci := format_numbers(pres, 3, "sci", decimal_mark = ",")]
DT[, engr := format_numbers(pres, 3, "engr", decimal_mark = ",")]

# render data frame in a table
knitr::kable(DT, 
             align = "r", 
             col.names = c("Pressure (Pa)", "scientific", "engineering"), 
             caption = "Comma as decimal separator")

# Reset to the preserved options 
options(backup_options)
```

Comment

- In the first column, "Pressure (Pa)", the comma decimal mark is formatted using the base R `OutDec` option. 
- In the second and third columns, the comma decimal marks are created by the `decimal_mark` argument of `format_numbers()`. 

<br>

*Big mark.* &nbsp; The big mark is the character that separates digits into groups of three to the left of the decimal mark. Used in decimal notation only. 

*Small mark.* &nbsp; The small mark is the character that separates digits into groups of three to the right of the decimal mark. Used in decimal notation only. 

The NIST recommends we use a thin space to separate more than 4 digits [@NIST:2022, 10.5.3]. 

> Because the comma is widely used as the decimal marker outside the United States, it should not be used to separate digits into groups of three. Instead, digits should be separated into groups of three, counting from the decimal marker towards the left and right, by the use of a thin, fixed space. However, this practice is not usually followed for numbers having only four digits on either side of the decimal marker except when uniformity in a table is desired.

The "thin" fixed space setting in formatdown can be applied via `big_mark` or `small_mark` or both. 

```{r}
DT <- water[, .(bulk_mod, visc)]
DT[, bulk_mod := format_numbers(bulk_mod/1000, 5, "dcml", big_mark = "thin")]
DT[, visc := format_numbers(visc*1000, 6, "dcml", small_mark = "thin")]
knitr::kable(DT, 
             align = "r", 
             col.names = c("Modulus (MPa)", "Viscosity (mPa$\\cdot$s)"), 
             caption = "Thin spaces as digit separators")
```


```{r}
#| echo: false
reset_formatdown_options()
```

Note that we do not employ the NIST recommendation to omit the thin space for 4 digits. 





## References

